# FloodGuard - Water Level Monitoring System

FloodGuard is a comprehensive web application for monitoring water levels, managing sensors, and handling flood reports. Built with Next.js, TypeScript, and Supabase.

## Features

- User authentication with email/password and Google OAuth
- Real-time water level monitoring
- Sensor management
- Report tracking
- Alert configuration
- Responsive design

## Tech Stack

- **Frontend**: Next.js 14, React, TypeScript, Tailwind CSS
- **Backend**: Supabase (Authentication, Database, Storage)
- **UI Components**: shadcn/ui
- **Charts**: Recharts
- **Date Handling**: date-fns

## Getting Started

### Prerequisites

- Node.js 18.x or later
- npm or yarn
- Supabase account

### Installation

1. Clone the repository:
   \`\`\`bash
   git clone https://github.com/yourusername/floodguard.git
   cd floodguard
   \`\`\`

2. Install dependencies:
   \`\`\`bash
   npm install
   # or
   yarn install
   \`\`\`

3. Set up environment variables:
   - Create a `.env.local` file with your Supabase credentials:
   \`\`\`
   NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
   \`\`\`

4. Set up the Supabase database:
   - Go to your Supabase project
   - Navigate to the SQL Editor
   - Run the following SQL script to create the necessary tables:

   \`\`\`sql
   -- Profiles table
   CREATE TABLE public.profiles (
     id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
     name varchar(255),
     avatar_url varchar(255),
     updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
   );

   -- Sensors table
   CREATE TABLE public.sensors (
     id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
     name varchar(255) NOT NULL,
     device_id varchar(255) UNIQUE NOT NULL,
     status varchar(50) DEFAULT 'active',
     location varchar(255),
     latitude float,
     longitude float,
     last_reading float,
     created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
     updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
   );

   -- Readings table
   CREATE TABLE public.readings (
     id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     sensor_id bigint REFERENCES public.sensors(id) ON DELETE CASCADE NOT NULL,
     water_level float NOT NULL,
     created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
   );

   -- Reports table
   CREATE TABLE public.reports (
     id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
     title varchar(255) NOT NULL,
     location varchar(255),
     description text,
     image_url varchar,
     status varchar(50) DEFAULT 'open',
     created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
     updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
   );

   -- Enable Row Level Security
   ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
   ALTER TABLE public.sensors ENABLE ROW LEVEL SECURITY;
   ALTER TABLE public.readings ENABLE ROW LEVEL SECURITY;
   ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

   -- Create policies
   CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
   CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
   CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

   CREATE POLICY "Users can manage their own sensors." ON public.sensors FOR ALL USING (auth.uid() = user_id);

   CREATE POLICY "Authenticated users can view readings." ON public.readings FOR SELECT USING (auth.role() = 'authenticated');

   CREATE POLICY "Authenticated users can view reports." ON public.reports FOR SELECT USING (auth.role() = 'authenticated');
   CREATE POLICY "Users can create their own reports." ON public.reports FOR INSERT WITH CHECK (auth.uid() = user_id);
   CREATE POLICY "Users can update their own reports." ON public.reports FOR UPDATE USING (auth.uid() = user_id);
   \`\`\`

5. Configure Google OAuth:
   - Go to your Supabase project settings
   - Navigate to Authentication > Providers
   - Enable Google provider
   - Create OAuth credentials in Google Cloud Console
   - Add the redirect URL from Supabase to your Google OAuth settings
   - Add your Google Client ID and Secret to Supabase

6. Run the development server:
   \`\`\`bash
   npm run dev
   # or
   yarn dev
   \`\`\`

7. Open [http://localhost:3000](http://localhost:3000) in your browser.

## Deployment

### Deploy to Vercel

1. Push your code to a GitHub repository
2. Import the project to Vercel
3. Add the environment variables
4. Deploy

## Project Structure

\`\`\`
floodguard/
├── app/                    # Next.js App Router
│   ├── auth/               # Authentication routes
│   ├── dashboard/          # Dashboard routes
│   ├── login/              # Login page
│   └── signup/             # Signup page
├── components/             # React components
│   ├── auth/               # Authentication components
│   ├── dashboard/          # Dashboard components
│   └── ui/                 # UI components (shadcn/ui)
├── lib/                    # Utility functions
├── public/                 # Static assets
└── styles/                 # Global styles
\`\`\`

## License

This project is licensed under the MIT License.
